<!DOCTYPE html>
<html>
<head>
    <title>Drone Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/0.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.1.0/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.socket.io/socket.io-3.0.0.js"></script>
    <script src="https://unpkg.com/aframe-curve-component/dist/aframe-curve-component.min.js"></script>
    <script src="https://unpkg.com/aframe-alongpath-component/dist/aframe-alongpath-component.min.js"></script>
    <!-- Curve and walk along path components -->
    <script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/v3.8.6/dist/aframe-extras.min.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-extras/v3.13.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.6.0/dist/aframe-look-at-component.min.js"></script> 
    <script src="https://unpkg.com/aframe-maze-component@0.1.24/dist/aframe-maze-component.min.js"></script>
    <script src="https://unpkg.com/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
</head>

<body>
    <a-scene id="myScene" physics="debug: true">
    <img id="texture-wall" src="/assets/arrow-left.png">
    <img id="texture-floor" src="/assets/floor-texture-1.jpg">
    <a-entity id="CollisonText"></a-entity>
    <a-box id="wall-one" 
          static-body material="src: #texture-wall" 
          depth="1" width="4" height="1"></a-box>
    <a-cylinder id="end-cap"
          static-body color="#444444" 
          depth="1.1" width="1.1" height="2"
          radius="0.5"></a-cylinder>
    <a-sky id="sky" color="#0000ff"></a-sky>
    <a-box id="center" 
          position="0 0 0"
          color="red" 
          depth="0.5" width="0.5" height="10"></a-box>
    <a-box static-body 
          depth="0.25" height="1" width="1" 
          position="-20 9.8 20"
          rotation="-90 0 0"
          color="tomato"></a-box>
    <a-entity id="maze1" 
          maze='size: 5 6; wall: #wall-one; cap: #end-cap; open: S 0 N 1 2 4 E 5;' 
          position='0 0.5 0'
          rotation='0 0 0' class="collidable"></a-entity>

      <a-entity id="maze2" 
          maze='size: 7 3; wall: #wall-one; cap: #end-cap; open: W 2 N 2 6;' 
          position='30 0.5 0'
          rotation='0 45 0' class="collidable"></a-entity>

      <a-entity id="maze3A" 
          maze='size: 5 6; wall: #wall-one; cap: #end-cap; open: S 0 N 4;' 
          position='25 0.5 -30' class="collidable"></a-entity>

      <a-entity id="maze3B" 
          maze='size: 5 6; wall: #wall-one; cap: #end-cap 0.4;' 
          position='25 4 -30' class="collidable"></a-entity>
          
      <a-entity id="maze4" 
          maze='size: 4 5; wall: #wall-one; cap: #end-cap;' 
          position='10 0.5 30' class="collidable"></a-entity>
          
       <a-entity id="maze5" 
          maze='size: 4 5;' 
          position='-30 0.5 -5' class="collidable"></a-entity>
        <a-entity id="ocean" ocean="density: 20; width: 50; depth: 50; speed: 4"
          material="color: #9CE3F9; opacity: 0.75; metalness: 0; roughness: 1"
          rotation="-90 0 0"></a-entity>
        <a-entity id="ocean" ocean="density: 20; width: 50; depth: 50; speed: 4"
          material="color: #9CE3F9; opacity: 0.75; metalness: 0; roughness: 1"
          rotation="-90 0 0"></a-entity>
        <a-simple-sun-sky sun-position="1 0.4 0"></a-simple-sun-sky>
        <a-grid id="ground" width="2000" height="2000" static-body material="src: #texture-floor"></a-grid>
        <a-sky id="sky" color="#0000ff"></a-sky>
        <a-plane id="floor" static-body height="1000" width="1000" position="0 -0.02 0" color="black" rotation="-90 0 0"></a-plane>
        <a-camera id="myCamera" position="0 -0.02 0" raycaster="objects: .collidable">
            <a-cursor intersection-spawn="event: click; mixin: voxel">
                <a-text id="playerName" value="Your Player Name" position="0 0.5 0" color="#ffffff"></a-text>
                <a-box id="colorBox" height="0.5" width="0.5" depth="0.5"></a-box>
            </a-cursor>
        </a-camera>
    </a-scene>
    <script>
        var player_home = {};
        var mycamera = document.getElementById('myCamera');
        var playerNameText = document.getElementById('playerName');
        var players = [];
        var player_Sockets = {};
        var player_Positions = {};
        // Get WebSocket URL from session storage
        const socketURL = sessionStorage.getItem('socketURLplayer');
        const player_name = socketURL.split('/').pop();
        playerNameText.setAttribute('value', player_name);
        const socketURLTeam = sessionStorage.getItem('socketURL')
        const socketTeam = io(socketURLTeam, {
                transports: ['websocket'],
            });
        // Set color
        fetch('/getcolor')
        .then(response => response.json())
        .then(data => {
            // Extract color from data (assuming data is in JSON format)
            const color = data.color;

            // Apply color to the box
            const box = document.getElementById('colorBox');
            box.setAttribute('color', color);
        })
        .catch(error => {
            console.error('Error fetching color:', error);
        });
        // Function to send WebSocket signal
        function sendWebSocketSignal(player_name, player_Position) {
            socketTeam.emit('Join', {Name: player_name, position: player_Position});
        }
        // Function to fetch position from endpoint and set it to the camera
        function setPositionFromEndpoint() {
            // Make AJAX request to the endpoint
            fetch('/getposition')
                .then(response => response.json())
                .then(data => { 
                    let position_string = `${data.x} ${data.y} ${data.z}`
                    mycamera.setAttribute('position',position_string);
                    player_home['myCamera'] = {x: data.x, y: data.y, z: data.z};
                    sendWebSocketSignal(player_name, {x: data.x, y: data.y, z: data.z});

                    // Set position from the data received from the endpoint
                })
                .catch(error => {
                    console.error('Error fetching position:', error);
                });
        }
        setPositionFromEndpoint();
        // Call the function initially to set the initial position
        var myposition = mycamera.getAttribute('position');
        // Check if socketURL exists before attempting to connect
        if (socketURL) {
            const socket = io(socketURL, {
                transports: ['websocket'],
            });
            player_Sockets[player_name] = socket;
            // Web Audio API
            var audio = new Audio('/static/industrial-pulse-drone-27456.mp3');
            audio.loop = true;

            socket.on('message', text => {
                handleCommand(text, "myCamera");
            });
        } else {
            console.error('WebSocket URL not found in session storage.');
        }
        socketTeam.on("Join", playerPos => {
            console.log(`${playerPos.Name} ${playerPos.position.x} ${playerPos.position.y} ${playerPos.position.z} has joined`);
            // Extract player name and position from the received data
            const playerName = playerPos.Name;
            const playerPosition = playerPos.position;

            if (playerName!= player_name && !players.includes(playerName)) {
                console.log("New Player Found");
                const cameraElement = document.createElement('a-entity');
                cameraElement.setAttribute('id', playerName);
                cameraElement.setAttribute('position', `${playerPosition.x} ${playerPosition.y} ${playerPosition.z}`);
                cameraElement.setAttribute('raycaster', 'objects: .collidable');
                // Create a-cursor element as a child of a-camera
                const cursorElement = document.createElement('a-cursor');
                cursorElement.setAttribute('intersection-spawn', 'event: click; mixin: voxel');

                // Create a-box element as a child of a-cursor
                const boxElement = document.createElement('a-box');
                boxElement.setAttribute('height', '0.5');
                boxElement.setAttribute('width', '0.5');
                boxElement.setAttribute('depth', '0.5');

                // Fetch color from endpoint
                fetch('/getcolor')
                .then(response => response.json())
                .then(data => {
                    // Extract color from data (assuming data is in JSON format)
                    const color = data.color;
                    // Apply color to the box
                    boxElement.setAttribute('color', color);
                })
                .catch(error => {
                    console.error('Error fetching color:', error);
                });
                const textElement = document.createElement('a-text');
                textElement.setAttribute('value', playerName);
                textElement.setAttribute('align', 'center');
                textElement.setAttribute('position', '0 0.5 0');
                // Append child elements
                cursorElement.appendChild(textElement);
                cursorElement.appendChild(boxElement);
                cameraElement.appendChild(cursorElement);

                // Append a-camera element to the scene
                document.getElementById('myScene').appendChild(cameraElement);
                // Listen for the 'loaded' event on cameraElement
                cameraElement.addEventListener('loaded', function () {
                    // Now that the entity is fully loaded, get the updated position
                    let newplayer = document.getElementById(playerName);
                    let newplayerSocketUrl = socketURLTeam + '/' + playerName;
                    let newplayerSocket = io(newplayerSocketUrl, {
                        transports: ['websocket'],
                    });
                    player_Sockets[playerName] = newplayerSocket;
                    player_home[playerName] = {x: playerPosition.x, y: playerPosition.y, z: playerPosition.z};
                    newplayerSocket.on('message', text => {
                        handleCommand(text, playerName);
                    });
                });
                sendWebSocketSignal(player_name, {x: player_home['myCamera'].x, y: player_home['myCamera'].y, z: player_home['myCamera'].z});
                players.push(playerName);
            }
        });

    
        function play_sound(){
            if (myposition.y === 0) {
                        // Stop playing the sound when the drone is on the ground
                        audio.pause();
                    } else {
                        // Continue playing the sound if the drone is not on the ground
                        audio.play();
                    }
        }

        function handleCommand(command, player) {
            var cc = document.getElementById(player);
            position = cc.getAttribute("position");
            var collisions = cc.components.raycaster.intersectedEls;
            // Example: Move the drone based on the command
            // You may need to use a library or API to control the drone's movement
            switch (command) {
                case 'up':
                    position.y = Math.min(position.y + 0.1, 10);
                    play_sound()
                    break;
                case 'down':
                    position.y = Math.max(position.y - 0.1, 0);
                    play_sound()
                    break;
                case 'left':
                    position.x = position.x - 0.1;
                    play_sound()
                    break;
                case 'right':
                    position.x = position.x + 0.1;
                    play_sound()
                    break;
                case 'forward':
                    position.z = position.z - 0.1;
                    play_sound()
                    break;
                case 'backward':
                    position.z = position.z + 0.1;
                    play_sound()
                    break;
                case 'stop':
                    break;
                case 'home':
                    // Define a curve starting from the current position and ending at 0 -0.02 0
                    var homeCurve = document.createElement('a-curve');
                    homeCurve.setAttribute('id', 'homeCurve');
                    homeCurve.innerHTML = `
                        <a-curve-point position="${position.x} ${position.y} ${position.z}"></a-curve-point>
                        <a-curve-point position="${player_home[player].x} ${player_home[player].y} ${player_home[player].z}"></a-curve-point>
                    `;
                    document.getElementById('myScene').appendChild(homeCurve);
                    // Calculate distance between current position and home position
                    var distance = Math.sqrt(
                        Math.pow(position.x, 2) +
                        Math.pow(position.y + 0.02, 2) +
                        Math.pow(position.z, 2)
                    );

                    // Set animation duration based on distance (adjust the factor as needed)
                    var duration = Math.max(1000, distance * 100); // At least 1000 milliseconds
                    // Animate the camera along the home curve
                    cc.setAttribute('alongpath', {
                        curve: '#homeCurve',
                        dur: duration,
                        loop: false
                    });
                    
                    setTimeout(function(){
                        document.getElementById('myScene').removeChild(homeCurve);
                        cc.removeAttribute('alongpath');
                    }, duration);
                    break;
                case 'collison':
                    // Define a curve starting from the current position and ending at 0 -0.02 0
                    var collisonCurve = document.createElement('a-curve');
                    var randomNumber = Math.floor(Math.random() * 20) + 1;
                    collisonCurve.setAttribute('id', 'collisonCurve');
                    collisonCurve.innerHTML = `
                        <a-curve-point position="${position.x} ${position.y} ${position.z}"></a-curve-point>
                        <a-curve-point position="${position.x+randomNumber} ${position.y - position.y} ${position.z}"></a-curve-point>
                    `;
                    document.getElementById('myScene').appendChild(collisonCurve);
                    // Calculate distance between current position and home position
                    var distance = Math.sqrt(
                        Math.pow(position.x, 2) +
                        Math.pow(position.y + 0.02, 2) +
                        Math.pow(position.z, 2)
                    );

                    // Set animation duration based on distance (adjust the factor as needed)
                    var duration = Math.max(1000, distance * 100); // At least 1000 milliseconds
                    // Animate the camera along the home curve
                    cc.setAttribute('alongpath', {
                        curve: '#collisonCurve',
                        dur: duration,
                        loop: false
                    });
                    
                    setTimeout(function(){
                        document.getElementById('myScene').removeChild(collisonCurve);
                        cc.removeAttribute('alongpath');
                    }, duration);
                    break;
                case 'rotate':
                    // Get Current Rotation
                    var initialPosition = cc.getAttribute('position');
                    var initialRotation = cc.getAttribute('rotation');
                    // Function to reset camera position and rotation
                    function resetCamera() {
                        cc.setAttribute('position', initialPosition);
                        cc.setAttribute('rotation', initialRotation);
                    }
                    // Set initial rotation
                    var currentRotation = 0;

                    // Store the reference to the animation frame request
                    var animationFrameId;

                    // Define function to continuously rotate the camera
                    function rotateCamera() {
                        // Increment rotation angle
                        currentRotation += 1;

                        // Set new rotation
                        cc.setAttribute('rotation', {
                            x: 0,
                            y: currentRotation,
                            z: 0
                        });

                        // Request next frame and store the request ID
                        animationFrameId = requestAnimationFrame(rotateCamera);
                    }

                    // Start rotating the camera
                    rotateCamera();

                    // Set a timer to stop rotation after 10 seconds (10000 milliseconds)
                    setTimeout(function() {
                        // Stop rotating the camera
                        cancelAnimationFrame(animationFrameId);
                        resetCamera();
                    }, 5000); // 10 seconds
                    break;    
            }
            // Update camera position
            cc.setAttribute('position', position);
            if (player!= "myCamera")
            {
                var distance = Math.sqrt(
                        Math.pow(position.x- myposition.x, 2) +
                        Math.pow(position.y - myposition.y + 0.02, 2) +
                        Math.pow(position.z- myposition.z, 2)
                    );
                if(distance< 0.1){
                    player_Sockets[player].emit('message', 'collison');
                }
            }
        }
    </script>
</body>
</html>
